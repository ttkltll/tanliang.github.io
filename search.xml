<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《流畅的python》阅读笔记1：杂谈</title>
    <url>/2020/06/02/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>1</p>
<p>这本书主要讲了什么呢？给我最大的收获是什么？以前我不太懂魔法函数的作用，这次我明白，魔法方法，可以让你自定义的对象，实现一些跟python内置对象一样的方法和操作，比如说，你的类实现<strong>repr</strong>,那么你就可以apply(repr(a)),来创建一个对象。比如你实现了<strong>eq</strong>,你就可以比较两个对象是不是一样。你自定义的对象有着跟python一样的操作符。这就是python的一致性，它让调用你写的类的用户学习成本降低，你只要像操作内置对象一样操作你的对象就行了。</p>
<p>2</p>
<p>作者先是讲解了python一些内置数据结构，比如数组，字典，等，然后自己实现一个vector类，来模仿这些python内置数据类型的一些行为。作者说，只有用过python的内置类型，才能自己定义出符合pythonic的数据模型。</p>
<p>以前我一直搞不懂序列，容器的区别，比如说：</p>
<p>序列和容器（collection),它们都可以迭代，但是只有序列可以按下标拿到值，也只有序列能够切片。</p>
<p>3</p>
<p>关于迭代器和生成器，学完这书，给我印象最深的是什么？就是迭代器，只要实现了<strong>repr</strong>方法，方法里面可以有这么几种情况，第一种是，你返回一个内置类型的迭代器，itor = repr(a), next(itor)调一次就可以返回一个值了，第二种方法，是自己实现一个，根据不同的数据结构，肯定又是有不同的实现方式，比如，如果是链表呢？那这个迭代器的<strong>next</strong>方法就不是通过下标来取值了。</p>
<p>关于生成器，它是由一个生成器函数，返回一个生成器。解释器用生成器函数，把函数体封装成一个迭代器，这样每次会生成一个数值。这种情况就适合数据量比较大的情况，如果一开始就把这么大数据存下来，很费内存，可以在用到的时候一个一个生成。</p>
<p>那么问题来了，什么函数是生成器函数呢？只要有yield关键字的函数，它就是生成器函数。它会返回一个生成器。</p>
<p>4</p>
<p>接下来讲讲Python中的协议，接口，鸭子类型。什么是协议，书上说是在代码中没有实现，但写在文档中，比如说，一个类要成为另一个类的子类，它不用继承自它，它只要实现一些魔法方法，它就是一个类的子类，比如你实现了<strong>iter</strong>方法，那么你用isinstance(a, abc.itor),它就会判断为true,什么是接口，就是一个类，你能供外部调用的属性或方法。</p>
<p>可变类型，它们一般都可以插入，可以删除。但不可变类型就不行，</p>
<p>上面这些，就是不看书的情况下，自己随意写的一些东西。</p>
]]></content>
      <categories>
        <category>《流畅的python》</category>
      </categories>
  </entry>
  <entry>
    <title>《流畅的python》阅读笔记2：切片及原理</title>
    <url>/2020/06/02/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02%EF%BC%9A%E5%88%87%E7%89%87%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>1：什么场景下我们会用到切片？</p>
<p>2：实现切片的原理，基于此，我们如何实现一个支持切片操作的自定义类型？</p>
<h3 id="下面说下什么场景下我们会用到切片？"><a href="#下面说下什么场景下我们会用到切片？" class="headerlink" title="下面说下什么场景下我们会用到切片？"></a>下面说下什么场景下我们会用到切片？</h3><p>当我们想截取一段代码，怎样操作呢？</p>
<p>比如下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>]</span><br><span class="line">array1 = array(<span class="string">'d'</span>, list)</span><br><span class="line">components = reprlib.repr(array1)</span><br><span class="line"><span class="comment"># 这个时候返回字符串:“array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])”</span></span><br><span class="line"><span class="comment"># 现在我们只要[及其后面到]的字符串，这个时候怎么办？</span></span><br><span class="line"><span class="comment"># 最笨的方法：一个一个取值:components[12],components[13]....,或者用for循环。但是python还提供了切片可以更便捷的操作：</span></span><br><span class="line"></span><br><span class="line">components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行代码解决了问题</span></span><br></pre></td></tr></table></figure>

<p>《流畅的python》示例10.2的<strong>repr</strong>就用到切片来组合一个新的“构造方法字符串”。</p>
<p>我们还知道切片是对象，这可以用于什么场景呢？请看下面一段代码与注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>invoice = <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>0....5...............</span></span><br><span class="line"><span class="string"><span class="meta">... </span>tan  168  male</span></span><br><span class="line"><span class="string"><span class="meta">... </span>guan 160  female</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面是一个字符串，现在要取出每一行的第一段和第二段，怎么办？最笨的思路就是按下标取。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = slice(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height = slice(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gender = slice(<span class="number">10</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 上面给每个slice对象取个名字，方便以后复用。以后直接写名字就可以了，不用记下标。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = invoice.split(<span class="string">'\n'</span>)[<span class="number">2</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line"><span class="meta">... </span>    print(item[name], item[height])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">tan   <span class="number">168</span>  </span><br><span class="line">guan  <span class="number">160</span></span><br></pre></td></tr></table></figure>

<h3 id="切片操作的原理是什么呢？"><a href="#切片操作的原理是什么呢？" class="headerlink" title="切片操作的原理是什么呢？"></a>切片操作的原理是什么呢？</h3><p>当我们调用list[0:8]的时候，解释器其实是把slice(0,8）这个对象传给list.<strong>getitem</strong>(self,slice),下面来看 Python 如何把 my_seq[1:3] 句法变成传给 my_seq.<strong>getitem</strong>(…) 的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> index  </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = MySeq()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]  </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>]  </span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]  </span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>]  </span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>]  </span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), slice(<span class="number">7</span>, <span class="number">9</span>, <span class="literal">None</span>))</span><br></pre></td></tr></table></figure>

<p><strong>getitem</strong>会根据传入的数据类型做不同的操作，下面我们通过自定义一个类，让它支持切片，来更好的理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._components[index]</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7 = Vector(range(<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])”</span><br></pre></td></tr></table></figure>

<p>这就有问题了，我们得到的切片应该也是Vector类，可现在是数组类型，如何解决呢？这就要用到我们上面说的切片原理了，我们要根据不同的类型，采取不同的手段。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)  </span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):  </span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])  </span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):  </span><br><span class="line">            <span class="keyword">return</span> self._components[index]  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展思考：用上面的方法，如何实现一个字典也能切片操作呢？</p>
</blockquote>
]]></content>
      <categories>
        <category>《流畅的python》</category>
      </categories>
  </entry>
  <entry>
    <title>《流畅的python》阅读笔记3：让代码更抽象</title>
    <url>/2020/06/03/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03%EF%BC%9A%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p> 注释：下面代码演示了如何让代码更抽象，更有应对变化的可能。下面（1）（2）（3）（4）（5）都是被否定的写法，也是一些初学者容易写出的代码。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#return iter(tuple(self.x, self.y))        （1）</span></span><br><span class="line">        <span class="comment">#这里可以改成用生成器：</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#return 'Vector2d(' + str(self.x) + ', ' + str(self.y) +')'    （2）</span></span><br><span class="line">        <span class="comment"># 上面这种写法，没有用到这个类的可迭代，如参数太多，你一个个赋值，那就难了,还有就是直接写Vector2d,如果以后这个类变了名字，就麻烦了。这种用+号拼接，是最直观的，但是字符串是不可变序列，它会占有用新的内存。</span></span><br><span class="line">        <span class="comment">#下面是一种好点的写法，但也不够好</span></span><br><span class="line">        <span class="comment">#return '&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'.format(class_name, self.x, self.y)    （3）</span></span><br><span class="line">        <span class="comment">#下面是更好的，能更好地应对变化，够抽象。</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment">#if self.x == other.x and self.y == other.y:       （4）</span></span><br><span class="line">        <span class="comment">#    return True</span></span><br><span class="line">        <span class="comment">#return False</span></span><br><span class="line">        <span class="comment">#上面的写法很大问题，先不说不 简捷，可以直接</span></span><br><span class="line">        <span class="comment">#return self.x == other.x and self.y == other.y      （5）</span></span><br><span class="line">        <span class="comment">#更好地写法是加直接调用内置类型来判断：</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self.x, self.y))</span><br></pre></td></tr></table></figure>



<p>这个系列未完待续…</p>
]]></content>
      <categories>
        <category>《流畅的python》</category>
      </categories>
  </entry>
  <entry>
    <title>SICP(1):函数式编程思维杂谈</title>
    <url>/2020/07/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>目前sicp看到第三章节，前两章完成了90%的习题，第三章看了一半。这篇文章主要是些杂谈，可能会有些抽象。后面的系列文章会更具体的讲解。SICP这个写作项目，大概会持续至少半年。</p>
<h5 id="先讲讲函数式思维和面向对象，软件设计的一些关系"><a href="#先讲讲函数式思维和面向对象，软件设计的一些关系" class="headerlink" title="先讲讲函数式思维和面向对象，软件设计的一些关系"></a>先讲讲函数式思维和面向对象，软件设计的一些关系</h5><p>这本书其实是讲，当一个系统越来越复杂时，怎样管理系统的复杂度。有三个方法，抽象，组合，DSL(领域特定语言)。抽象和组合可以更好地封装代码。让下层的实现细节不会影响到上层的使用。面象对象思维不过是其实一种，还可以通过数据驱动设计，消息传递等其它手段。另外，<strong>面象对象思维和面向对象编程语言是两回事</strong>。什么意思呢？你用Lisp系语言也可以达到面向对象思维，用C语言也可以。比如linux内核用C写的就很面向对象（我没看过，在哪本书上看到的）。当然你用java这种“纯正”的面向对象语言，你可以显式的定义类，对象。而且你不用管那么多细节，比如垃圾回收，这个虚拟机会帮你做。但你用C语言可不行，你要自己做。各有优势。</p>
<p>所谓函数式思维编程，这里的函数，不是编程语言中的函数，而是数学中的，<strong>数学中的函数强调一对一映射</strong>。什么意思呢？就是给定相同的参数x,就一定会得到相同的结果，在严格的函数式思维中，变量是代数中的变量，一个值的名称，它是不可能改变的。而在命令式语言中，变量是存储状态的单元，可以改变，可以被赋值的，比如x = x+1,但是这个表达式在数学看来就是不可取了。</p>
<p>函数式思维中，也是没有循环的，在普通的java循环中，是要有一个变量做累积的，比如i++,即i = i +1。纯函数编程语言无法实现循环，这是因为For循环使用可变的状态作为计数器，而While循环需要可变的状态作为跳出循环的条件。因此在函数式语言里就只能使用递归来解决迭代问题，这使得函数式编程严重依赖递归。严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程。</p>
<p>那么到底是命令式编程语言好，还是函数式好呢？调用《道德经》的思维:<strong>没有对错，只有合适不合适</strong>。两种语言都有它们的最适用场景。面向对象的本质是什么？OOP之父Alan Kay说：“OOP is all about messaging”,利用OOP建模，就是在各个对象中传递消息。而现实的大多业务场景，都可以建模成人或者其它对象的协作，通过消息来协作。比如你下个订单，这个对象的库存数减少，新建一个订单对象，等等。这种场景，用OOP是很自然的建模过程。当然你用函数式编程的各种函数“动作”来建模这个过程也是可以的。但是这个场景，用OOP和FP,哪个更好理解呢。举另外一个场景，你就是对一组数据做加工，先排序，再查询，然后再转换。这个场景，显然用FP来建模更自然，这一看就可以看成是一个“管道”过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (f1(f2(f3...(fn data))))..</span><br></pre></td></tr></table></figure>

<p>但如果这个场景用OOP语言呢？每个过程建立一个class?这很别扭。不简洁。</p>
<p>另外，因为函数式编程的不可赋值特性，让它在并发处理上有优势，SICP上有讲，我还没理解透这块。</p>
<h5 id="总结下就是：一个业务，它抽象成OOP更自然，用OOP-抽象成函数过程更好理解，用FP。"><a href="#总结下就是：一个业务，它抽象成OOP更自然，用OOP-抽象成函数过程更好理解，用FP。" class="headerlink" title="总结下就是：一个业务，它抽象成OOP更自然，用OOP,抽象成函数过程更好理解，用FP。"></a>总结下就是：一个业务，它抽象成OOP更自然，用OOP,抽象成函数过程更好理解，用FP。</h5><p><strong>那么，函数式思维和命令式语言最本质的区别是什么？</strong>命令式语言，它是按照这件事“怎么做”一步一步去执行的，而函数式语言不同，它是描述“是什么”，它不管你完成一件事的具体步骤，相当于数学中的表达式求值。所以这会更抽象。</p>
<p>比如我们要对一个列表操作，让它每个数都开平方。怎么做呢？用python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">  a = i * i</span><br><span class="line">  list2.append(a)</span><br><span class="line"><span class="comment"># 这种思维是把列表里的数先转换，再加到表里去。一个一个的进行。</span></span><br></pre></td></tr></table></figure>

<p>用scheme:</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="comment">;通过描述一个 旧列表-&gt;新列表 的映射，而不是描述「从旧列表得到新树应该怎样做」来达到目的.</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> list1 (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;输出结果：</span></span><br><span class="line">&gt; (map square list1)</span><br><span class="line">(<span class="name">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span>)</span><br></pre></td></tr></table></figure>



<p>先说到这，下一篇文章写什么呢？写高阶函数或者数据导向的程序设计和可加性。</p>
<h3 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog:"></a>Changelog:</h3><p>20200710 15：40: 完成草稿</p>
<p>20200711 11：09：完成文章</p>
]]></content>
      <categories>
        <category>《计算机程序的构造和解释》（SICP)</category>
      </categories>
  </entry>
  <entry>
    <title>学习背后的认知科学原理</title>
    <url>/2018/01/22/%E5%AD%A6%E4%B9%A0%E8%83%8C%E5%90%8E%E7%9A%84%E8%AE%A4%E7%9F%A5%E7%A7%91%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>一直以来，不管是求学时代还是工作中，总有些人学习新东西特别快。“别人聪明嘛，老天爷就是不公平”成了很多人低下学习效率的一个安心，逃避的解释。当然在这里我必须承认一点，有些人确实智商高一点，“CPU”跑得比别人快一点，“内存”容量也比一般人大点。但是，我还是要表达我的观点：其实每个人都有一个差不了太多的大脑，都还是几十万年前狩猎时代的远古人。那些看似聪明的人，更有可能是有好的学习方法。如果你掌握了这些方法。你也能成为别人眼中的“聪明人”。</p>
<p>比如教你阅读的《如何阅读一本书》：提倡阅读要积极主动，要在分析阅读之前检视阅读，要不断的自己给自己提问题。要主题阅读。<br>比如斯科特的《如何高效学习》：要你用自己的话多输出，要你多用类比，要你把理解的东西转化成图象，要你搭建跨学科知识体系。<br>比如《越读者》：也提倡你要跨越学科来学习，多做主题阅读。<br>又比如《如何学习》：要你在学习之前想好学习的目的，针对不同的目的采取不同的学习策略</p>
<p>这些书提到的学习方法都是符合认知科学，脑科学原理的。背后的脑科学，认知科学的原理是什么呢？我觉得至少包括这些：</p>
<ul>
<li>1大脑擅长对比以及模式识别。</li>
<li>2记忆不过是思考的残留物。（1）</li>
<li>3记忆的提取效应，间隔效应，生成效应。避免记忆的“流利效应”。(2）（3）（4）（5）</li>
<li>4大脑用旧的知识来理解新的知识。否则就是硬塞到脑子里。（6）</li>
<li>5注意力的运行原理。（7）</li>
</ul>
<p>为什么要主题阅读。比如你最近要研究进化，复杂科学这个主题。那你的做法是买一批书，而不是只看一本书。先看一本最经典的。扫下目录，看有哪些关键词，大致讲了哪些知识点。然后假装自己要写一本这样的书应该怎么写。拿个笔记本或者为知笔记开始写下这些知识，提些问题。如果针对这些知识点你本来就有一定的知识结构。那自己先写下自己对这些知识点的理解。写完之后，再针对每个知识点去参考不同的书，这个时候你会发现，你的大脑就像装了导航，而且对于看过的东西印象很深刻。</p>
<p>为什么要自己先思考一遍？因为大脑爱对比。先思考再看书，你立马会发现作者跟你想的哪里不同，记忆特别深刻。</p>
<p>为什么主题阅读要参考不同的书？还是因为大脑擅长对比。针对一个知识点，你很容易发现不同作者对这个知识点哪里不同，或者是看问题的角度不同，或者是应用场景不同。比如对于进化复杂系统这个主题里的一个知识点：三论（信息论控制论系统论）。你可以在吴军的《硅谷之谜》里看他是如何用三论分析硅谷的历史的，你也可以看《控制论与科学方法论》这本70年代写的书是如何用三论分析化学，分析生态系统，分析导弹的。</p>
<p>当然主题阅读还有一个更重要的原因，为了多角度的认知事物。任何表达不过是看待事物的一个洞孔。都不全面。</p>
<p>为什么要多输出，背后的原理就是记忆的提取效应。你对一个知识点思考得多，本质就是在大脑”硬盘“里提取出相关知识。提取得多，自然能够记忆牢固。记忆不过是思考的残留物。为什么要用自己的话呢？为什么要多用类比呢？想想高中老师是如何给我们讲地球结构的就明白了。特别是对于一些你从来没见过，或者抽象的知识，更要用打比方，举例子。明白这个理论也有一个作用，也是我的一个偏见。就是我看一个人写的东西。如果发现全是理论，没有例子，或者打比方。你都不知识他在说什么。要么这是个牛得不行，懒得举例子的大神，要么是这个人自己都完全搞不明白自己写的东西到底是什么？</p>
<p>为什么有些人可以把很深的东西讲得深入浅出。其实这是很难的。而且也要花大量的时间去思考：我如何能够把这个知识点讲清楚，让街上的老太太都能明白。那你得找她能听懂的例子，或者类比啊。而这个找的过程其实就是加深你理解一个抽象事物的过程。举例言之：比如你如何让一个高中生能够听懂”控制论“的大致思想。你得找他可能熟悉的例子，见过的东西啊（上面不说了吗，理解的本质是用旧知识联系新知识）。你跟他讲老鹰讲火箭。他应该是见过的吧。</p>
<p> 老鹰是怎么抓兔子的呢？它不可能在看见兔子的瞬间，就算好方程吧！那就用眼睛估计下和兔子的距离，先大致地冲过去。一直盯着它，向鹰脑报告自己的方位，和兔子的方位进行比较，不断调整自己的动作，减小目标差，直到目标差为0，逮到兔子。这就是控制论里的负反馈调节机制：不断把自己的控制后果与目标比较，在一次次控制中减少目标差，最终扩大了控制能力的过程。其实导弹火箭都用到了控制论，否则你看电视怎么那导弹像长了眼睛一样的追着乱飞的战斗机呢？现在互联网提倡的精益创业方法论。本质上也是用到控制论的思想。扯远了。。。</p>
<p>用类比可能帮助我们认识事物，但也只是片面的，比如上面的老鹰例子也只是讲清楚了控制论里的负反馈调节这一环。其它的知识点当然还要找其它的类比或者例子。类比用在理解新事物上是好东西啊，可很多人喜欢用在论证自己的观点上。后果不堪设想。。。。。</p>
<p>为什么要跨学科学习，为什么看一本书之前要先想清楚阅读的目的，为什么在分析阅读之前要检视阅读，先提些问题，带着问题去阅读？我觉得注意力的原理可以提供一个很好的解释。先来讲讲注意力的简单原理。不知道大家有没有想过，客观的世界，对于每个人其实都是相同的。一本书上的文字，它并不会因你看是一些文字。因为另一人看就增加或者减少一些文字。电影也是一样。那么这里就有个问题出现了。为什么同一部电影，同一本书，不同的人或者同一人不同时间能注意到的，记忆到的细节会有那么大的差别呢？其实，如果说得简单一点，有三方面的因素决定你是否能注意到一些细节：知识，经验，以及你的目的。</p>
<p>举例言之：对于拥有跨学科知识人，比如说懂概率统计，又懂认知科学，又有些历史思维的人。看《未来简史》这种书能注意到的细节绝对比知识面狭窄的人要多。这同样可以解释看电影的一些现象。比如初中你看《黑客帝国》，只是觉得很科幻。但随着你有了些生活经验，哲学思维。你重看了一遍。只是这次看完，你一整夜都在思考些什么。我也听很多人说看星爷电影的事。小时候觉得只是好笑，可现在看《喜剧之王》，经常哭得稀里哗拉。书还是那本书，电影还是那部电影，它们就在那里。只是随时岁月的流逝，你有了更多的经验，更多的知识，也有了不同的价值观（这会影响到你看书和电影的目的）。同样也很好解释，一个机会，有人隔着山都能抓住,而有些人，就算机会在他面前跳桑巴，也全当视而不见。甚至故作清高。机会本不存在，它只存在大脑的神经回路当中。说得更准确一点,他早就躲在你的神经回路中守株待兔,等待现实世界中所谓的机会出现时,然后谈一场恋爱。有一点投资经验的人，应该能够体会到这种无为的思维。有些人是刻意的去找机会，太强为了。眼睛看不到东西，我们说这个人瞎了。那么一个机会就在你眼前，你也看不到，是不是也是一种瞎呢？看不到东西，很可能是因为你的硬件坏了。比如视网膜脱落。机会看不到，往往是因为你没有装必要的软件，这个软件里面是一些知识，以及思考方法。</p>
<p>觉得应该总结下：就是什么各种阅读方法不重要，关键是要知道背后的脑科学原理。知道了脑科学原理，自己也可以创造些方法（术）。甚至也可以有效地利用一些方法。比如说：有人说做思维导图有用，有人觉得没什么用，甚至还有争吵。可这不是重点，思维导图不过是个工具（器）。有人做思维导图是这样的：看完书立马做导图，而且基本是抄。这当然没效果。违背了记忆的提取效应和间隔效应。如果你是学了个东西，隔一天做导图，而且尽量不抄（而是去大脑硬盘提取）。那当然效果是很好的。所以导图只是个工具，看你怎么用。</p>
<p>有些人可能会反驳说：那为什么有些人不知道认知科学，也没学什么学习方法。人家也学东西特别快。我承认这是事实，我高中读书时也有这样的同学。但是这不能否认这些同学的学习方法无意中就符合认知科学的原理。没有说人类要习得一个技能，先得搞清楚它的原理才会做。类似的例子太多。比如几千年前人类就“发明”了冥想，直到近代科学才发现冥想对人的各种好处。（8）</p>
<p>说说钱钟书吧。你说他们那时候也没有什么脑科学知识供他们参考。他是碰巧发现了符合”脑科学认知科学“的读书方法吗？然后用得很爽就一直用下去。钱钟书阅读的一个特点就是很喜欢输出。大量的读书思考笔记。我觉得一个更好的解释是：他有强烈的好奇心。好奇心是这个世界上具备反脆弱的事物。具备反脆弱事物的特点是能够在大周期的时间内保持。比如说你对一样事物特别感兴趣，哪怕你走一些弯路，多花点时间，几年之内也是可以学会的。但是如果你的学习完全是受外界的影响，很有可能会半途而废，比如一些考证的人。</p>
<p>什么是反脆弱？就是你越是抵制它，它会越强烈。你会发现一个人对一样事物有着天然的好奇心的时候，他自然会去思考为什么，自然会去买这个领域不同人写的书看。这个过程是很自然的。它”无意中“符合了上面几条认知科学规律：比如提取和对比。如果说阅读存在一个”道”的话，那应该让位于天然的好奇心吧！如何定义这个天然的好奇心。我觉得标准就是，你学习它可以带来心流体验，可以给你带来快乐。而不是我学这个东西就能给我带来外在的名声，以及物质的回报。兴趣建立在这两个假设之上，是很难经受时间考验的。比如考证，一旦失败就没动力坚持下去。这里有一个问题，你怎么知道你对一个事物是有天然的好奇心？万一这个好奇心只是在“我看别人也在学这个”“或者“我觉得学了这个就会怎样怎样“的驱使下呢？如何定义天然的好奇心？我觉得这是一个值得思考的问题。也是个不会有答案的问题。我自己也老是问这个问题。比如我以前学一样东西，真的是自己真正的好奇吗？当然了，事情并不是一分为二。要么是全部天然的好奇，要么就不是天然的好奇。中间还有很多过渡状态。比如我想研究一个东西既有天然的兴趣也有其它原因（比如又有物质回报，以及精神奖励岂不更好）。只是这个天然占比多少？也许只有自己的心知道。任何人都不能给我们答案。只是有件事应该记住：人是最善于自我欺骗的动物。  </p>
<p>其实还是有一个简单的方法可以鉴别好奇心。就是时空变幻。问问自己，如果独自一人,去另一星球。或者坐着时光机器，来到唐朝。你还有心思琢磨这玩意吗？当然，这个假设有点严格的。</p>
<p>似乎扯远了，我们回到前面。钱钟书这些人，在没有认知科学原理指导的情况下，也习得了高效学习的方法。我想第一是运气好，第二得靠悟性。</p>
<p>不过，我们现代人还是很幸运。我们可以直接享受脑科学认知科学家们发现的研究成果。科学规律的一个好处是：后来人可以直接用这条规律来解释，来预测，来实践。知道背后的规律，可以大范围的推广。而古代的那些人，他们大多只能靠自己”悟“了。</p>
<p>如果好奇心是学习的“道”，那么背后的认知科学原因只能算做“术”了，而各种各样的具体方法，只是“术”演绎出来的“器”。</p>
<p>最后再多说些个人体会：对于一本书，应根据不同情况调用不同方法。什么是不同情况，有哪些不同情况？每个人都应该有自己的标准。比如我是根据一本书的性质，还有我的目的这两块决定的。举例言之：</p>
<p>比如对于一本经典，又对认知很有帮助的书，本应该采用分析阅读，这么好的书对吧。但如果我的目的只是想阅读它其实一章节的内容呢，比如在主题阅读中经常会有这种情况。我在研究认知偏差这个主题。发现这本经典的一个章节专门讲到脑神经这个知识点。而我现在研究认知偏差正好在脑神经这块有点理解困难。那我不用分析阅读它。我不应该成为书的奴隶，书是为我的研究服务的。每本书就好像我请来的专家，我有需要会“问”你们的。你不用把所有知识都告诉我，我现在不需要。</p>
<p>同样的道理，如果是一份报纸或者是杂志。按道理这种快餐式的资料，大概检视阅读下就足够了。但如果你想研究别人的写作方式或者思考方式，那你也得用分析阅读。</p>
<p>所以，应该根据书的种类，你的目的这两块（还可以有其实因素）来决定调用哪种阅读技能。掌握的阅读技能越多，在碰到具体问题的时候会有更大的灵活性。技多不压身。</p>
<blockquote>
<p>参考文献：<br>（1）《为什么学生不喜欢上学》第三章P49<br>（2）<a href="https://en.wikipedia.org/wiki/Fluency" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fluency</a><br>（3）<a href="https://en.wikipedia.org/wiki/Testing_effect" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Testing_effect</a><br>（4）<a href="https://en.wikipedia.org/wiki/Varied_practice" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Varied_practice</a><br>（5）<a href="https://en.wikipedia.org/wiki/Spacing_effect" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Spacing_effect</a><br>（6）《为什么学生不喜欢上学》第四章<br>（7）《认知心理学：心智，研究与你的生活》第四章<br>（8）Meditation experience is associated with increased cortical thickness <a href="http://t.cn/zOE2WPn" target="_blank" rel="noopener">http://t.cn/zOE2WPn</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>阅读flask源码:错误处理</title>
    <url>/2020/04/09/%E9%98%85%E8%AF%BBflask%E6%BA%90%E7%A0%81-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>read</category>
      </categories>
  </entry>
  <entry>
    <title>阅读flask源码1：flask请求流程</title>
    <url>/2020/04/04/%E9%98%85%E8%AF%BBflask%E6%BA%90%E7%A0%811%EF%BC%9Aflask%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>我们先大致的走下flask处理请求的流程，我用的是flask0.1这个版本的源码。之所以用这个，是为了去除不必要枝叶，快速把握flask的主干。后面再迭代，加细节。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Request, request, session, flash, abort, _request_ctx_stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">web.register(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面会注册路由：</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    req = request.url</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> app.url_map</span><br><span class="line"><span class="keyword">print</span> app.view_functions</span><br><span class="line">app.run(debug=<span class="literal">True</span>, port=<span class="number">8004</span>)</span><br></pre></td></tr></table></figure>

<p>当我们运行这个入口文件，先实例化一个app对象，后面执行视图函数的路由注册。这个时候，app的url_map,view_function已经有值了。然后运行app.run()。我们进入run()方法内部：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, host=<span class="string">'localhost'</span>, port=<span class="number">5000</span>, **options)</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">from</span> werkzeug <span class="keyword">import</span> run_simple</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'debug'</span> <span class="keyword">in</span> options:</span><br><span class="line">        self.debug = options.pop(<span class="string">'debug'</span>)</span><br><span class="line">    options.setdefault(<span class="string">'use_reloader'</span>, self.debug)</span><br><span class="line">    options.setdefault(<span class="string">'use_debugger'</span>, self.debug)</span><br><span class="line">    <span class="keyword">return</span> run_simple(host, port, self, **options)</span><br></pre></td></tr></table></figure>



<p>这个run()方法，会返回run_simple(),这个方法是werkzeug模块里的，会启动一个服务器，run()方法把这个app的实例作为参数传给了run_simple。</p>
<p>服务器会监听浏览器传过来的信息，接着服务器把信息environ,start_response传给WSGI application,也就是实例化的app。environ包括所有的请求信息，start_response是 application 处理完之后需要调用的函数，参数是状态码、响应头部还有错误信息。</p>
<p>服务器端会调用<strong>call</strong>方法，<strong>call</strong>方法返回app自己的wsgi_app()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""Shortcut for :attr:`wsgi_app`"""</span></span><br><span class="line">    <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br></pre></td></tr></table></figure>

<p>我们进入wigi_app内部看下，这里就是WSGI application处理请求的主干了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        rv = self.preprocess_request()</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            rv = self.dispatch_request()</span><br><span class="line">        response = self.make_response(rv)</span><br><span class="line">        response = self.process_response(response)</span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure>



<p>这些代码做了什么事呢？</p>
<p>先用environ封装一个请求上下文对象，并且把这个上下文压入到栈中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> self.request_context(environ):</span><br></pre></td></tr></table></figure>



<p>为什么这个语句可以做到这件事呢？是因为request_context（）方法会返回一个_RequestContext对象，而这个对象实现了<strong>enter</strong>方法。这里不展开。然后是做调用preprocess_request()函数做一些预处理。现在还没有进入视图函数。然后才是调用dispatch_request()函数，这个函数做什么呢？主要是分发路由，找到匹配的视图函数来处理请求。把结果返回给rv变量。再接着调用make_response()函数对rv封装，把它转换成一个符合格式的Response对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = self.process_response(response)</span><br></pre></td></tr></table></figure>

<p>这句会对response做进一步处理。主要是调用after_request_funcs列表里的函数。这个列表，由一些函数组成。这些函数可以通过after_request（）注册。最后返回return response(environ, start_response)。respsose可以被调用，是因为response是一个实现了<strong>call</strong>方法的类，到此，整个流程已经走完了。</p>
<blockquote>
<p>先把流程走通了，以后再阅读下蓝图模块，错误处理模块，请求上下文模块的源码</p>
</blockquote>
]]></content>
      <categories>
        <category>阅读flask源码</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读flask源码2：Local,LocalStack</title>
    <url>/2020/04/09/%E9%98%85%E8%AF%BBflask%E6%BA%90%E7%A0%812%EF%BC%9ALocal-LocalStack/</url>
    <content><![CDATA[<p>我们还是以flask0.1的代码来阅读,先提出几个常见的问题：</p>
<p>1上下文是怎么被压入栈的？</p>
<p>2为什么在不同的程序中通过相同的变量request可以拿到对应的请求</p>
<p>我们先看第一个问题：上下文是怎么被压入栈的？</p>
<p>服务器传过来的请求参数，被封装成了一个_RequestContext对象，这个对象里有这个请求相关联的一组互相“绑架”的参数，它们组成一个上下文环境。比如request,被实例化的app。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RequestContext</span><span class="params">(object)</span>:</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, environ)</span>:</span></span><br><span class="line">        self.app = app</span><br><span class="line">        self.url_adapter = app.url_map.bind_to_environ(environ)</span><br><span class="line">        self.request = app.request_class(environ)</span><br><span class="line">        self.session = app.open_session(self.request)</span><br><span class="line">        self.g = _RequestGlobals()</span><br><span class="line">        self.flashes = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        _request_ctx_stack.push(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, tb)</span>:</span></span><br><span class="line">        <span class="comment"># do not pop the request stack if we are in debug mode and an</span></span><br><span class="line">        <span class="comment"># exception happened.  This will allow the debugger to still</span></span><br><span class="line">        <span class="comment"># access the request object in the interactive shell.</span></span><br><span class="line">        <span class="keyword">if</span> tb <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> self.app.debug:</span><br><span class="line">            _request_ctx_stack.pop()</span><br></pre></td></tr></table></figure>

<p>这个对象实现了<strong>enter</strong>,所以通过with context语句。对象被压入到一个栈中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">       <span class="string">"""Pushes a new item to the stack"""</span></span><br><span class="line">       rv = getattr(self._local, <span class="string">"stack"</span>, <span class="literal">None</span>) <span class="comment"># 如果没有stack,那么就返回none,然后给_local创建一个stack属性。</span></span><br><span class="line">       <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           self._local.stack = rv = [] <span class="comment"># 新建一个列表，把这个列表给自己的属性_local,它是一个对象。</span></span><br><span class="line">       rv.append(obj) <span class="comment"># 给自己的属性_local的属性，加上一个上下文环境对象，这个对象在请求进来时已经通过with实例化了一个。</span></span><br><span class="line">       <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>

<p>字典的键是线程Id,值就是被压入的，封装了特定请求的上下文对象。那么问题来了，正常情况下，context被压入栈中，栈里应该是context对象啊。是怎么实现里面有字典的呢？</p>
<p>压入栈中，这个压入，可不是压入一个普通的列表，这个列表，将做为Local对象的一个属性stack</p>
<p>这个LocalStack初始化的时候，封装了一个Local对象。为什么要这样做呢？这就回答了上面的问题，Local可以实现线程隔离，拿到当前线程的上下文。</p>
<p>这里Local实现了一个<strong>setattr</strong>方法，这样可以加上线程了，现在上下文按放在一个Local对象的字典中，</p>
<p>上面是存储好了上下文环境 ，下面是讲解，怎么通过全局变量拿到request的呢？</p>
<p>我们进入视图函数了，我们输入：request.url。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    req = request.url</span><br><span class="line">    <span class="keyword">return</span> req</span><br></pre></td></tr></table></figure>

<p>这个时候，request是一个代理对象，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.request)</span><br></pre></td></tr></table></figure>

<p> _request_ctx_stack.top.request)会从栈中取出最上面的对象，并且拿到栈最上面的上下文对象。</p>
<p>它本身没有url属性，所以会触发LocalProxy的<strong>getattr</strong>属性。这个时候，拿到request对象的url属性。</p>
]]></content>
      <categories>
        <category>阅读flask源码</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>重学计算机网络</title>
    <url>/2022/03/19/%E9%87%8D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="缘起："><a href="#缘起：" class="headerlink" title="缘起："></a>缘起：</h3><p>记得大一大二学过计网，那时候老师讲得也不清楚。主要是为了考试，没有从理解上学习。后来做后端开发，网络编程这块，框架都给你封装好了。你不用了解底层。但http应用层协议还是要懂的。就看了《网络是怎么连接的》，以及极客时间一门课叫《透视http协议》。这就是我之前全部的计算机网络学习经历。后来觉得这些资料讲得还是太浅显，就下定决心，系统学下《计算机网络：从顶向下的方法》这本神作。</p>
]]></content>
  </entry>
  <entry>
    <title>研究python解释器（1）-python名字空间</title>
    <url>/2022/10/18/%E7%A0%94%E7%A9%B6python%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%881%EF%BC%89-python%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<blockquote>
<p>最近看了《python源码剖析》，把印象深刻的点写下来。自己的体会：只有深入源码，才能理解python中某些概念的本质。</p>
</blockquote>
<h3 id="关于python作用域："><a href="#关于python作用域：" class="headerlink" title="关于python作用域："></a>关于python作用域：</h3><p>文本作用域，编译器都是通过换行来区分的，比如模块对象，类对象，函数对象，它们都对应着一个代码对象。这个代码对象有它维护的环境。</p>
<h3 id="关于赋值："><a href="#关于赋值：" class="headerlink" title="关于赋值："></a>关于赋值：</h3><p>什么是赋值，其实就是把一个变量和一个对象绑定起来。在python中，变量只是一个名字而已。它可以随意和一个对象绑定起来。所以python中，不光=号，import, as, def class,这些背后都是赋值。本质都是把一个变量和一个对象绑定，对象可以是一个函数体，可以是一个常量。</p>
<h3 id="python虚拟机运行的原理"><a href="#python虚拟机运行的原理" class="headerlink" title="python虚拟机运行的原理"></a>python虚拟机运行的原理</h3><p>每个作用域对应一个代码对象，这个对象里有虚拟机代码要用到的常量，变量。还有“机器”代码本身。虚拟机每调用一次函数，就要把代码对象压入虚拟机的栈中。每个代码对象就是一个栈帧，每个栈帧都有自己的作用域。当运行到最里面的函数时，碰到return返回数据，数据从当前栈帧的数据栈中弹出，同时当前栈帧从虚拟机中弹出。当前环境变成下面一个栈帧。并且把return的值传给当前栈帧的一个变量。然后用这个变量代入当前栈帧的代码对象去运算。如果有返回值，继续弹出。这样直到<strong>main</strong>函数。</p>
<p>背后的思想:虚拟机其实要解决哪些问题呢？首先是管理作用域的问题。如果用python来写，可以用对象来管理每个栈帧。每个对象都可以维护自己的数据变量。而用C语言实现的话，就要借用结构体。还有就是栈这种数据结构。在python中没有专门的栈这种数据模型，强以通过列表实现。</p>
]]></content>
      <tags>
        <tag>python解释器原理</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读flask源码3：仿写Local,LocalStack</title>
    <url>/2020/04/16/%E9%98%85%E8%AF%BBflask%E6%BA%90%E7%A0%813%EF%BC%9A%E4%BB%BF%E5%86%99Local-LocalStack/</url>
    <content><![CDATA[<p>我们上篇分析了上下文压入栈，出栈的大致流程，现在我们要问，flask是怎么实现的呢？准备来说，Local是怎么管理不同请求对象的，LocalProxy是怎么代理的。因为flask源码太复杂，今天我们自己一步一步实现类似于Local,LocalProxy的代码。通过自己实现，我们学会用代理模式，学会python的魔法方法<strong>setattr</strong>,<strong>getattr</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AProxy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        print(<span class="string">'B1.spam'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._a.spam(x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B1.foo'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._a.foo()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B1.bar'</span>)</span><br><span class="line"></span><br><span class="line">b1 = AProxy()</span><br><span class="line">b1.spam(<span class="number">1</span>)</span><br><span class="line">b1.foo()</span><br><span class="line">b1.bar()</span><br></pre></td></tr></table></figure>

<p>这里的b1,是一个对象，我们访问b1.spam(1),它会返回类A的一个实例的方法。b1.foo（）也同理。</p>
<p>这个代理的问题是，我们写代理的时候，要先知道被代理的类A有哪些方法，下面我们实现一种更通用的代理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AProxy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line">        self.name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">      	<span class="keyword">return</span> getattr(self._a,key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B1.bar'</span>)</span><br><span class="line"></span><br><span class="line">b1 = AProxy()</span><br><span class="line">b1.spam(<span class="number">1</span>)</span><br><span class="line">b1.foo()</span><br><span class="line">b1.bar()</span><br></pre></td></tr></table></figure>

<p>上面这个代理，比第一个就抽象了，这晨用<strong>getattr</strong>实现了什么呢？只要你访问AProxy没有的方法，它就会去<strong>getattr</strong>中找，这个函数实现了你给一个函数名，它会给你被代理对象的函数。这里是一个抽象。</p>
<p>上面这个函数，只是实现了属性，方法的访问，却不能给它赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      	self.log = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AProxy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line">        self.name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">      	<span class="keyword">return</span> getattr(self._a,key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self,name,value)</span>:</span></span><br><span class="line">      	<span class="keyword">return</span> setattr(self._a,name,value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B1.bar'</span>)</span><br><span class="line"></span><br><span class="line">b1 = AProxy()</span><br><span class="line">b1.name = <span class="string">'我是AProxy的一个实例'</span></span><br><span class="line">b1.log = <span class="string">'我是A的一个实例'</span></span><br></pre></td></tr></table></figure>

<p>这个代理就比前一个更好用了，因为它可以给A的实例间接赋值。我们调用b1.log,这个时候AProxy没有这个属性，这时就去<strong>setattr</strong>中找，把log,’我是A的一个实例’作为实参，传给<strong>setattr</strong>。</p>
<p>当然这个代理也有些问题，就是它还不够抽象，它现在只能代理类A,如果我们希望它还能代理其它类怎么办呢？</p>
<p>改进如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      	self.log = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AProxy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self，object)</span>:</span></span><br><span class="line">        self._a = object</span><br><span class="line">        self.name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">      	<span class="keyword">return</span> getattr(self._a,key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self,name,value)</span>:</span></span><br><span class="line">      	<span class="keyword">return</span> setattr(self._a,name,value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B1.bar'</span>)</span><br><span class="line">a1 = A</span><br><span class="line">b1 = AProxy(a1)</span><br><span class="line">b1.name = <span class="string">'我是AProxy的一个实例'</span></span><br><span class="line">b1.log = <span class="string">'我是A的一个实例'</span></span><br></pre></td></tr></table></figure>

<p>这里通过一个给AProxy传参初始化，可以拿到不同的实例代理。</p>
<p>有了上面这些基础，现在我们模仿Local,LocalProxy来写一个代理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url = <span class="string">'tanliang.com'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.owner = <span class="string">'tanliang'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._objs = &#123;&#125;</span><br><span class="line">        self._objs[<span class="string">'request'</span>] = Request()</span><br><span class="line">        self._objs[<span class="string">'user'</span>] = User()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Local.__getattr__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._objs[name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalProxy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, local, name)</span>:</span></span><br><span class="line">        self._local = local</span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_current_obj</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'_get_current_obj'</span>)</span><br><span class="line">        <span class="keyword">return</span> getattr(self._local, self._name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'SpamProxy.__getattr__'</span>)</span><br><span class="line">        <span class="keyword">return</span> getattr(self._get_current_obj(), name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name ,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__setattr__(name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            setattr(self._obj, name, value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'SpamProxy.__delattr__'</span>)</span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__delattr__(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'SpamProxy'</span>, name)</span><br><span class="line">            delattr(self._obj, name)</span><br><span class="line"></span><br><span class="line">l = Local()</span><br><span class="line"></span><br><span class="line">request = l(<span class="string">'request'</span>)</span><br><span class="line">print(request)</span><br><span class="line">print(request.url)</span><br><span class="line"></span><br><span class="line">user = l(<span class="string">'user'</span>) </span><br><span class="line">print(user.owner)</span><br></pre></td></tr></table></figure>

<p>这里l是一个Local实例，request是一个代理对象，LocalProxy的实例，因为Local实现了<strong>call</strong>方法。当我们访问request.url时，会发生什么呢？先找到<strong>getattr</strong>,然后把url作为参数传给getattr。可是这个时候还没有拿到“当前对象”。self.<strong>get_current_obj()就是拿当前对象的，最后能过Local的</strong>getattr__拿到request对象。</p>
]]></content>
      <categories>
        <category>阅读flask源码</category>
      </categories>
  </entry>
</search>
